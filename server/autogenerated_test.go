package server

import (
	"sort"
	"testing"
)

func TestIsAutogeneratedPath(t *testing.T) {
	tests := []struct {
		path     string
		expected bool
	}{
		// Not autogenerated
		{"main.go", false},
		{"server/handler.go", false},
		{"README.md", false},
		{"src/app.ts", false},

		// Autogenerated by extension
		{"api.pb.go", true},
		{"api.pb.gw.go", true},
		{"stringer_string.go", true}, // stringer output for type "stringer"
		{"day_string.go", true},
		{"types.gen.go", true},
		{"types.generated.go", true},
		{"types_generated.go", true},
		{"service.mock.go", true},
		{"service_mock.go", true},
		{"bundle.min.js", true},
		{"styles.min.css", true},
		{"types.d.ts", true},
		{"queries.sql.go", true},

		// Autogenerated by directory
		{"vendor/github.com/pkg/errors/errors.go", true},
		{"node_modules/lodash/index.js", true},
		{"__pycache__/module.pyc", true},
		{"generated/models.go", true},
		{"gen/api.go", true},

		// Autogenerated lock files
		{"go.sum", true},
		{"package-lock.json", true},
		{"yarn.lock", true},
		{"pnpm-lock.yaml", true},
		{"Cargo.lock", true},
		{"uv.lock", true},
	}

	for _, tt := range tests {
		t.Run(tt.path, func(t *testing.T) {
			if got := IsAutogeneratedPath(tt.path); got != tt.expected {
				t.Errorf("IsAutogeneratedPath(%q) = %v, want %v", tt.path, got, tt.expected)
			}
		})
	}
}

func TestIsAutogeneratedGoContent(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		expected bool
	}{
		{
			name:     "regular go file",
			content:  "package main\n\nfunc main() {}\n",
			expected: false,
		},
		{
			name:     "code generated comment",
			content:  "// Code generated by stringer; DO NOT EDIT.\n\npackage main\n",
			expected: true,
		},
		{
			name:     "do not edit",
			content:  "// DO NOT EDIT\n\npackage main\n",
			expected: true,
		},
		{
			name:     "generated in comment",
			content:  "// auto-generated file\n\npackage main\n",
			expected: true,
		},
		{
			name:     "bindata",
			content:  "package main\n\nfunc bindataRead(name string) ([]byte, error) {\n",
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := isAutogeneratedGoContent([]byte(tt.content)); got != tt.expected {
				t.Errorf("isAutogeneratedGoContent() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestGitFileInfoSortOrder(t *testing.T) {
	// Test that files are sorted with non-generated first, then generated
	files := []GitFileInfo{
		{Path: "api.pb.go", IsGenerated: true},
		{Path: "main.go", IsGenerated: false},
		{Path: "go.sum", IsGenerated: true},
		{Path: "handler.go", IsGenerated: false},
		{Path: "types_generated.go", IsGenerated: true},
	}

	// Sort using the same logic as handleGitDiffFiles
	sort.Slice(files, func(i, j int) bool {
		if files[i].IsGenerated != files[j].IsGenerated {
			return !files[i].IsGenerated
		}
		return files[i].Path < files[j].Path
	})

	// Expected order: handler.go, main.go, api.pb.go, go.sum, types_generated.go
	expected := []string{"handler.go", "main.go", "api.pb.go", "go.sum", "types_generated.go"}
	for i, exp := range expected {
		if files[i].Path != exp {
			t.Errorf("position %d: expected %s, got %s", i, exp, files[i].Path)
		}
	}
}
